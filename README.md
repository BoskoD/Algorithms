# Note to Myself

| Topic  | Algorithm  | Apporach |
| :------------ |:--------------- |:----- |
| Array, HashTable      | TwoSum | It uses a Dictionary (**HashTable**) as a data structure to store the elements of the array along with their indices. While iterating through the array, for each element nums[i], it calculates target - nums[i] and checks if this value is already present in the Dictionary. If found, it means there is a valid pair of elements whose sum is equal to the target value. |
| String, Stack         | ValidParentheses | It uses a **Stack** data structure to keep track of the opening brackets while iterating through the input string. Whenever an opening bracket is encountered, it is pushed onto the stack. When a closing bracket is found, it is checked if its corresponding opening bracket is at the top of the stack. If so, the opening bracket is popped from the stack. The algorithm continues this process until the end of the string. If the stack becomes empty at the end, the string contains valid parentheses; otherwise, it is not valid. |
| Array, HashTable, Recursion | ContainsDuplicate | It employs a **HashSet** data structure to keep track of unique elements encountered while iterating through the array. For each element in the array, it attempts to add it to the HashSet using the Add method. If the Add method returns false, it means the element already exists in the HashSet, indicating a duplicate in the array. |
| LinkedList, Recursion | MergeTwoSortedLists | It uses a **recursive** approach to handle different cases when comparing nodes from both lists. The base cases are when one of the lists is empty, in which case the other list is returned. If neither list is empty, it checks whether the val of the first node in list1 is less than or equal to the val of the first node in list2. Depending on the result, it recursively sets the next node of the current list to the result of merging the rest of the lists. |
| HashTable, String, Sorting | Valid Anagram | Use 2 **HashTable** to count each letter in both strings, then compare counts to validate. Anagram is valid if all chars from sCounter have the same count as tCounter. |
| Array, HashTable, String, Sorting | Group Anagrams | Takes an array of strings as input, iterate through each string, and generate a key by counting the occurrences of each character. **Example hash[c - 'a']++.** Strings with the same key are considered anagrams, and they are grouped together in the dictionary. Finally, the method returns a list of lists, where each list represents a group of anagrams. |
| Two Pointers, String | Valid Palindrome | Takes a string as input, use **two pointers**, while they do not meet, check for all characters, are they digit or letter IsLetterOrDigit(s[left]) and IsLetterOrDigit(s[right]), if not move pointers left++ and right--, if they are letter or digit, unify them all - ToLower() and check if left char is equal to right char. |
| Array, HashTable, Heap(PriorityQueue), LINQ | TopKFrequentElements | Take int array as input, use **Hashmap** to map occurences of each num in the array, utilize **Heap (PriorityQueue)** to pull max k elements. |
| Array, PrefixSum | ProductOfArrayExceptSelf | Take an integer array as input, iterate through the array linearly from left to right, and then from right to left, calculating **prefix** and **postfix** sums, respectively. The prefix and postfix sums are multiplied together to obtain the result. |
| Array, TwoPointers | TwoSum II - Input Array is Sorted | Considering sorted input array, we can use **2 pointers** and evaluate their sum against the target. If the sum > target, decrease right pointer, if the sum < target increase left pointer. |
| Array, TwoPointers, Sorting | 3Sum | Sort input array, then considering sorted input array, we can evaluate first value 1/3 by checking if **nums[i] == nums[i-1]** in that case we contninue to prevent duplicate combinations, then use **2 pointers** and evaluate their sum + firt element that we have against 0. If the sum > 0, decrease right pointer, if the sum < 0 increase left pointer. |
| Array, Binary Search | Binary Search | Binary Search can be applied to a **sorted array** by using **two pointers and a mid pointer**. To avoid potential overflow, it is recommended to calculate the **mid pointer as left + ((right - left) / 2**). The algorithm evaluates the midpoint against the target and adjusts the pointers accordingly (**left = mid + 1 or right = mid - 1**) until the target element is found or the search space is exhausted. |
| Array, Dynamic Programming | Best Time to Buy and Sell Stock | This problem can be efficiently solved using **dynamic programming and two pointers**. The left pointer tracks the minimum price seen so far, representing the best time to buy the stock. The right pointer then scans through the prices to determine the maximum profit achievable by selling the stock at the highest price after the corresponding minimum buying price is found. |
| LinkedList, Two Pointers | ReverseLinkedList | This problem can be efficiently solved using **two pointers** instead of recursion. Set previous to null and current to head. While current is not null, perform the swap. Current.next point to previous, previous to current and current to temp which was initially set to current.next. Better memory then recursive approach. |
| Array, HashTable | LongestConsecutiveSequence | Use a **HashSet** to convert the input array nums. Determine if a number is the start of a sequence by checking if it has a left neighbor. If **!set.Contains(n-1)**, then the number is the start of a sequence. Count the length of the sequence and keep track of the longest one using Math.Max. |
| Array, Two Pointers, Greedy | ContainerWithMostWater | Use **two pointers** for linear time. While left < right, calculate _area = Math.Min(height[left], height[right]) * (right - left);_ and take Math.Max of result and area to get max area we need. If left height is less then right height, move left pointer left++, else move right pointer right--. |
| Array, Two Pointers, Dynamic Programming | TrappingRainWater | Use **two pointers** for linear time and constant space. We need to calculate space between bars where units of water can be captured, while left < right, take Math.Min of maxLeft and height[left], add substracted value of maxLeft - height[left] to the result. In case left is not less then right do the same from right to left. |
| Stack, Design | MinStack | Initialize **2 stacks** a normal stack and a stack to track a minimum value. On Push(), if minimumStack is not empty, check the top min value and if it is greater or equal to the new coming in, then push new value as new min on top of the minimumStack and then push value to original stack. On Pop(), pop from both. On Top(), Peek the top value from the stack. On GetMin(), peek the value from minimumStack. |
| Array, Binary Search, Matrix | Search2DMatrix | Use 2x **BinarySearch**. First finding in wich row the target should be, by spliting rows to mid and checking if target is bigger then last number in mid row or less then first num in mid row. When we find a row, do a simple BinarySearch on the row where the numebr is to find it. |
